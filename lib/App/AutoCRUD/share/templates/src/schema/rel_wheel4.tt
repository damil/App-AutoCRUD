[%~ WRAPPER linked_style %][% base %]static/css/ashbury-d3.css[% END ~%]
[%~ WRAPPER linked_script %][% base %]static/js/d3.js[% END ~%]


[%# ---------- start body ---------- %]

<style>
  body {
  font: 10px sans-serif;
}


.grp-label {
  font-size: 10px;
  font: sans-serif;
  text-anchor: middle;
}

</style>


<div id="wheel" data-json-url="./relationships4.json"></div>


<script type="text/javascript">

/* 

   TODO
   - radius change
   - labels 90°
   - add fade
   - handle for scaling

    DOC : http://devdocs.io/d3~4


*/



var rotate = 0;
var div;
var m0;
var svg;


//----------------------------------------------------------------------------



// see https://bl.ocks.org/mbostock/4062006
// https://bl.ocks.org/mbostock/1046712



var jsonURL = d3.select("#wheel").attr("data-json-url");
d3.json(jsonURL, build_wheel);



function build_wheel(data) {

  if (!data.nodes.length) {
    d3.select("#wheel").html("<p class='lead nodata'>No Data Available</p>");
    return;
  }

  // dimensions
  var margin = {left:90, top:90, right:90, bottom:90},
      outerSize = 800,
      width =  outerSize - margin.left - margin.right,
        // more flexibility: Math.min(window.innerWidth, 1000)
      height =  outerSize - margin.top - margin.bottom,
        // same: Math.min(window.innerWidth, 1000)
      innerRadius = Math.min(width, height) * .39,
      outerRadius = innerRadius * 1.1,
      opacityDefault = 0.7;


  // create scale and layout functions
  var color = d3.scaleOrdinal(d3.schemeCategory20);
  var chord = d3.chord()
    .padAngle(0.03)
    .sortChords(d3.descending);
  var arc = d3.arc()
    .innerRadius(innerRadius*1.01)
    .outerRadius(outerRadius);
  var ribbon = d3.ribbon()
    .radius(innerRadius);



  // create SVG
  div = d3.select("#wheel");
  svg = div.append("svg")
    .attr("width", width)
    .attr("height", height);
  var g = svg.append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
    .datum(chord(data.matrix));



  // draw outer arcs
  var outerArcs = g.selectAll("g.group")
    .data(function(chords) { return chords.groups; })
    .enter().append("g")
    .attr("class", "group")
    .on("mouseover", fade(.1))
    .on("mouseout", fade(opacityDefault))
    ;


  outerArcs.append("path")
    .style("fill", function(d) { return color(d.index); })
    .style("stroke", function(d) { return d3.rgb(color(d.index)).darker(); })
    .attr("d", arc);


  // title attribute
  outerArcs.append("title").text(function(d) {
    return data.nodes[d.index]; // nom de la table 
    });


  // append label names on the outside
  outerArcs.append("text")
      .attr("dy", ".35em") //width
      .attr("class", "grp-label")
      .attr("transform", function(d,i) { //angle
        d.angle = (d.startAngle + d.endAngle) / 2; //calculate the average of the start angle and the end angle
        d.name = data.nodes[i]; 
        return "rotate(" + (d.angle * 180 / Math.PI) + ")" +
          "translate(0," + -1.1 * (outerRadius + 10) + ")" +
          ((d.angle > Math.PI * 3 / 4 && d.angle < Math.PI * 5 / 4) ? "rotate(180)" : "");
      }) //to spin when the angle between 135 to 225 degrees
      .text(function(d) {
        return d.name;
      });
      


//Draw the ribbons that go from group to group
  var ribbons =  g.append("g")
    .attr("class", "ribbons")
    .selectAll("path")
    .data(function(chords) { return chords; })
    .enter().append("path")
      .attr("class", "chord")
      .attr("d", ribbon)
      .style("opacity", opacityDefault)
      .style("fill", function(d) { return color(d.target.index); })
      .style("stroke", function(d) { return d3.rgb(color(d.target.index)).darker(); });


  // tooltip pour chaque ruban
  ribbons.append("title").
    text(function(d){
      return data.nodes[d.source.index] + " => " + data.nodes[d.target.index];
    });


    d3.select(window)
        .on("mousedown", function(d) { mousedown(svg, outerRadius); } )
        .on("mousemove", function(d) { mousemove(svg, outerRadius); } )
        .on("mouseup",   function(d) { mouseup(svg, outerRadius); } );


}





//----------------------------------------------------------------------------
//Returns an event handler for fading a given chord group.
function fade(opacity) {
  return function(d,i) {
    svg.selectAll("path.chord")
        .filter(function(d) { return d.source.index != i && d.target.index != i; })
    .transition()
        .style("opacity", opacity);
  };
}//fade


//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

function mousedown(svg, r) {

    m0 = mouse(d3.event, r, r);
    d3.event.preventDefault();
}

//----------------------------------------------------------------------------

function mousemove(svg, r) {

    if (! m0) return;

    var m1 = mouse(d3.event, r, r);
    rotate += Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;

    if (rotate > 360) rotate -= 360;
    else if (rotate < 0) rotate += 360;

 //   svg.attr("transform", "translate(" + r + "," + r + ")rotate(" + rotate + ")");
   svg.attr("transform", "rotate(" + rotate + ")");

    m0 = m1;
}

//----------------------------------------------------------------------------

function mouseup(svg, rx, ry) {

    m0 = null;

    svg.selectAll("g.node text")
        .attr("dx", function(d) { return (d.x + rotate) % 360 < 180 ? 8 : -8; })
        .attr("text-anchor", function(d) { return (d.x + rotate) % 360 < 180 ? "start" : "end"; })
        .attr("transform", function(d) { return (d.x + rotate) % 360 < 180 ? null : "rotate(180)"; });

    return true;
}

//----------------------------------------------------------------------------

function cross(a, b) {

    return a[0] * b[1] - a[1] * b[0];
}

//----------------------------------------------------------------------------

function dot(a, b) {

    return a[0] * b[0] + a[1] * b[1];
}

//----------------------------------------------------------------------------

function mouse(e, rx, ry) {

  var containerRect =  div.node().getBoundingClientRect();
    var xOffset = containerRect.left + window.scrollX;
    var yOffset = containerRect.top  + window.scrollY;

    return [e.pageX - rx - xOffset, e.pageY - ry - yOffset];


}

//----------------------------------------------------------------------------

function updateNodes(svg, name, value) {

    return function(d) {
        if (value) this.parentNode.appendChild(this);
            svg.select("#node-" + d[name].key).classed(name, value);
    };
}





</script>
