[%~ WRAPPER linked_style %][% base %]static/css/ashbury-d3.css[% END ~%]
[%~ WRAPPER linked_script %][% base %]static/js/d3.js[% END ~%]


[%# ---------- start body ---------- %]

<style>
  body {
  font: 10px sans-serif;
}


.grp-label {
  font-size: 10px;
  font: sans-serif;
  text-anchor: middle;
}

.ribbons {
  fill-opacity: 0.6;
}
</style>


<div id="wheel" data-json-url="./relationships4.json">
   <svg width="960" height="960"></svg>
</div>


<script type="text/javascript">

/* 

   TODO
   - radius change
   - labels 90°
   - add fade

    DOC : http://devdocs.io/d3~4


*/



var rotate = 0;
var div;
var m0;
var svg;
var g;


//----------------------------------------------------------------------------



// see https://bl.ocks.org/mbostock/4062006
// https://bl.ocks.org/mbostock/1046712



var jsonURL = d3.select("#wheel").attr("data-json-url");

function build_wheel(data) {

  if (!data.nodes.length) {
    d3.select("#wheel").html("<p class='lead nodata'>No Data Available</p>");
    return;
  }


  var margin = {left:90, top:90, right:90, bottom:90},
      outerSize = 500,
    width =  outerSize - margin.left - margin.right, // more flexibility: Math.min(window.innerWidth, 1000)
    height =  outerSize - margin.top - margin.bottom, // same: Math.min(window.innerWidth, 1000)
    innerRadius = Math.min(width, height) * .39,
    outerRadius = innerRadius * 1.1;

  // create SVG
  // svg = d3.select("#wheel").append("svg")
  //   .attr("width", width + margin.left + margin.right)
  //   .attr("height", height + margin.top + margin.bottom)
  //   .append("g")
  //   .attr("transform", "translate(" + (width/2 + margin.left) + "," + (height/2 + margin.top) + ")")
  //   .datum(chord(matrix));


  // dimensionnement de la div
  div = d3.select("#wheel")
    .style("width", width + "px")
    .style("margin", "0 auto");

  // dimensionnement du canevas
  svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height);



  // initialisation du diagramme chord
  var chord = d3.chord()
    .padAngle(0.1)
    .sortChords(d3.descending);

  // définition des arcs 
  var arc = d3.arc()
    .innerRadius(innerRadius*1.01)
    .outerRadius(outerRadius);

  // définition des "rubans"
  var ribbon = d3.ribbon()
    .radius(innerRadius);

  //Initialize colors to an ordinal scheme
  var color = d3.scaleOrdinal(d3.schemeCategory20);
  // var color = d3.scaleOrdinal()
  //   .domain(d3.range(4))
  //   .range(["#000000", "#FFDD89", "#957244", "#F26223"]);


  //What does this do?
  g = svg.append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
    .datum(chord(data.matrix));

  //Defines each "group" in the chord diagram
  var group = g.append("g")
    .attr("class", "groups")
    .selectAll("g")
    .data(function(chords) { return chords.groups; })
    .enter().append("g");


  //Draw the radial arcs for each group
  group.append("path")
    .style("fill", function(d) { return color(d.index); })
    .style("stroke", function(d) { return d3.rgb(color(d.index)).darker(); })
    .attr("d", arc)
    .on("mouseover", fade(.1))         /* Where attempt at mouseover is made */
    .on("mouseout", fade(1));


  // ajout d'un titre pour chaque groupe
  group.append("title").text(function(d) {
    return data.nodes[d.index]; // nom de la table 
    });


  //Add labels to each group
  group.append("text")
      .attr("dy", ".35em") //width
      .attr("class", "grp-label")
      .attr("transform", function(d,i) { //angle
        d.angle = (d.startAngle + d.endAngle) / 2; //calculate the average of the start angle and the end angle
        d.name = data.nodes[i]; 
        return "rotate(" + (d.angle * 180 / Math.PI) + ")" +
          "translate(0," + -1.1 * (outerRadius + 10) + ")" +
          ((d.angle > Math.PI * 3 / 4 && d.angle < Math.PI * 5 / 4) ? "rotate(180)" : "");
      }) //to spin when the angle between 135 to 225 degrees
      .text(function(d) {
        return d.name;
      });
      

  // STRATOPAN does it like this
        // .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
        // .append("svg:text")
        // .attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
        // .attr("dy", ".31em")
        // .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
        // .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
        // .text(function(d) { return d.name; })




//Draw the ribbons that go from group to group
  var ribbons =  g.append("g")
    .attr("class", "ribbons")
    .selectAll("path")
    .data(function(chords) { return chords; })
    .enter().append("path")
      .attr("d", ribbon)
      .style("fill", function(d) { return color(d.target.index); })
      .style("stroke", function(d) { return d3.rgb(color(d.target.index)).darker(); });


  // tooltip pour chaque ruban
  ribbons.append("title").
    text(function(d){
      return data.nodes[d.source.index] + " => " + data.nodes[d.target.index];
    });






    // svg.selectAll("path.link")
    //     .data(links)
    //     .enter().append("svg:path")
    //     .attr("class", function(d) { return "link source-" + d.source.key + " target-" + d.target.key; })
    //     .attr("d", function(d, i) { return line(splines[i]); });

    // svg.selectAll("g.node")
    //     .data(nodes.filter(function(n) { return !n.children; }))
    //     .enter().append("svg:g")
    //     .attr("class", "node")
    //     .attr("id", function(d) { return "node-" + d.key; })
    //     .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
    //     .append("svg:text")
    //     .attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
    //     .attr("dy", ".31em")
    //     .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
    //     .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
    //     .text(function(d) { return d.name; })
    //     .on("mouseover", function(d) { mouseover(d, svg); } )
    //     .on("mouseout",  function(d) { mouseout(d, svg);  } );

    d3.select(window)
        .on("mousedown", function(d) { mousedown(svg, outerRadius); } )
        .on("mousemove", function(d) { mousemove(svg, outerRadius); } )
        .on("mouseup",   function(d) { mouseup(svg, outerRadius); } );


}

d3.json(jsonURL, build_wheel);




//----------------------------------------------------------------------------
//Returns an event handler for fading a given chord group.
function fade(opacity) {
  return function(d,i) {
    svg.selectAll("path.chord")
        .filter(function(d) { return d.source.index != i && d.target.index != i; })
    .transition()
        .style("opacity", opacity);
  };
}//fade


//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

function mousedown(svg, r) {

    m0 = mouse(d3.event, r, r);
    d3.event.preventDefault();
}

//----------------------------------------------------------------------------

function mousemove(svg, r) {

    if (! m0) return;

    var m1 = mouse(d3.event, r, r);
    rotate += Math.atan2(cross(m0, m1), dot(m0, m1)) * 180 / Math.PI;

    if (rotate > 360) rotate -= 360;
    else if (rotate < 0) rotate += 360;

 //   svg.attr("transform", "translate(" + r + "," + r + ")rotate(" + rotate + ")");
   svg.attr("transform", "rotate(" + rotate + ")");

    m0 = m1;
}

//----------------------------------------------------------------------------

function mouseup(svg, rx, ry) {

    m0 = null;

    svg.selectAll("g.node text")
        .attr("dx", function(d) { return (d.x + rotate) % 360 < 180 ? 8 : -8; })
        .attr("text-anchor", function(d) { return (d.x + rotate) % 360 < 180 ? "start" : "end"; })
        .attr("transform", function(d) { return (d.x + rotate) % 360 < 180 ? null : "rotate(180)"; });

    return true;
}

//----------------------------------------------------------------------------

function cross(a, b) {

    return a[0] * b[1] - a[1] * b[0];
}

//----------------------------------------------------------------------------

function dot(a, b) {

    return a[0] * b[0] + a[1] * b[1];
}

//----------------------------------------------------------------------------

function mouse(e, rx, ry) {

  //var m = d3.mouse(div._groups[0][0]);

  // var m = d3.mouse(div.node());
  // return [m[0] - rx, m[1] - ry];

  var containerRect =  div.node().getBoundingClientRect();
    var xOffset = containerRect.left + window.scrollX;
    var yOffset = containerRect.top  + window.scrollY;

    return [e.pageX - rx - xOffset, e.pageY - ry - yOffset];


}

//----------------------------------------------------------------------------

function updateNodes(svg, name, value) {

    return function(d) {
        if (value) this.parentNode.appendChild(this);
            svg.select("#node-" + d[name].key).classed(name, value);
    };
}

</script>
